---
sidebar_position: 4
---

## 1 原理分析

为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来：

1. 假设 Java 堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞**（Pointer Bumping）。
2. 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**空闲列表**（Free List）。
3. **选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。** 因此：
   1. 在使用**Serial**、**ParNew**等带有**Compact**过程的收集器时，系统采用的分配算法时**指针碰撞**。
   2. 在使用**CMS**这种基于**标记-清除算法**的收集器时，通常采用**空闲列表**。

**指针碰撞：**

![](https://notebook.ricear.com/media/202105//1621914623.735002.png)

**空闲列表：**

![](https://notebook.ricear.com/media/202105//1621914623.7397084.png)

## 2 参考文献

1. [指针碰撞和空闲列表](https://blog.csdn.net/yun_ld/article/details/105103011)。

