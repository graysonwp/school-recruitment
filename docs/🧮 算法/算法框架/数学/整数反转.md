---
sidebar_position: 3
---

## 1 题目

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。
**示例 1：**

```txt
输入：x = 123
输出：321
```

**示例 2：**

```txt
输入：x = -123
输出：-321
```

**示例 3：**

```txt
输入：x = 120
输出：21
```

**示例 4：**

```txt
输入：x = 0
输出：0
```

**提示：**

* -231 <= x <= 231 - 1

## 2 问题分析

1. **反转一个整数时**，我们**只需要拿到这个整数的末尾数字就可以了**，例如在反转 12345 时，先拿到 5，再拿到 4，之后是 3、4、1，我们按这样的顺序就可以反向拼接成一个数字了，也能达到反转的效果。
2. **拿末尾数字时**，**用取模运算就可以了**，例如拿 12345 的末尾数字：
   1. 将 $ 12345 \% 10 $ 得到 5，之后将 $ 12345 / 10$。
   2. 将 $ 1234 \% 10 $ 得到 4，之后将 $ 1234 / 10$。
   3. 将 $ 123 \% 10 $ 得到 3，之后将 $ 123 / 10$。
   4. 将 $ 12 \% 10 $ 得到 2，之后将 $ 12 / 10$。
   5. 将 $ 1 \% 10 $ 得到 1，之后将 $ 1 / 10$。
      
      ![1.jpg](https://notebook.grayson.top/media/202201/2022-01-15_1643490.28884188943836187.png)
3. 因为要**考虑负数**，**所以上述循环的判断条件是 $x != 0$**。
4. 同时因为【假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 `[−2^31,  2^31 − 1]`】，所以我们**不能用 `long` 存储最终结果**，而且**有些数字可能是合法范围内的数字**，但是**翻转过来就可能超过范围了**，例如 1147483649，本身是小于最大的 32 位整数 2147483647 的，但是将这个数字反转过来后就变成了 9463847411，这就比最大的 32 位整数还要大了，这样的数字没法存到 `int` 里，所以肯定要返回 0（溢出了），所以我们需要**在反转的过程中不断判断反转的临时结果 $res$ 是否溢出**，**如果溢出的话**，**直接返回 0**，具体判断规则如下：
   1. $res > 214748364 || (res == 214748364 \&\& temp > 7)$，即 $res$ 大于最大的 32 位整数。
   2. $res < -214748364 || (res == -214748364 \&\& temp < -8)$，即 $res$ 小于最小的 32 位整数。
      
      > 注：$temp = x % 10$，即每次取的末尾数字。
      
      ![2.jpg](https://notebook.grayson.top/media/202201/2022-01-15_1650070.6591399192263269.png)
      
      ![3.jpg](https://notebook.grayson.top/media/202201/2022-01-15_1650170.16949562176053135.png)

## 3 参考代码

```java
/**
 * 7. 整数反转
 * @param x 要反转的整数
 * @return  反转后的整数
 */
public int reverse(int x) {
    int res = 0;
    while (x != 0) {
        //  每次取末尾数字
        int temp = x % 10;
        //  判断是否大于最大 32 位整数
        if ( res > 214748364 || (res == 214748364 && temp > 7)) {return 0;}
        //  判断是否小于最小 32 位整数
        if (res < -214748364 || (res == 214748364 && temp < -8)) {return 0;}
        //  拼接结果
        res = res * 10 + temp;
        //  修改要反转的整数
        x /= 10;
    }
    return res;
}
```

## 参考文献

1. [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer)。
2. [图解 7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/solution/tu-jie-7-zheng-shu-fan-zhuan-by-wang_ni_ma)。



