---
sidebar_position: 7
---

## 1 HTTP1.0 和 HTTP1.1 的区别

1. **缓存处理**：

   1. 在 HTTP1.0 中主要使用`header` 里的`If-Modified-Since,Expires` 来作为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，例如`Entity tag`、`If-Unmodified-Since`、`If-Match`、`If-None-Match` 等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**：

   1. HTTP1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象都送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头中添加了`range` 字段，他允许只请求资源的某个部分，这样就方便了开发者自由的选择，以便于充分的利用带宽。
3. **错误通知的管理**：

   1. 在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Confilct）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host 头处理**：

   1. 在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求头中的 URL 并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个 IP 地址，HTTP1.1 的请求消息和响应消息都应该支持 Host 字段，请求消息中如果没有 Host 字段会报 400（Bad Request）。
5. **长连接**：

   1. HTTP1.1 支持长连接和请求的流水线处理（Pipeling），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 `Connection: keep-alive`，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

      > Pipeling 是什么？
      > Pipeling 是指**若干个请求排队串行化单线程处理**，**后面的请求等待前面的请求的返回才能获得执行机会**，**一旦有某请求超时**，**后续请求只能被阻塞**，也就是人们常说的**线头阻塞**。
      >

## 2 HTTP1.1 和 HTTP2.0 的区别

1. **多路复用**：

   1. 多路复用允许同时**通过单一的 HTTP/2 连接发起多重请求**，在**HTTP/1.1 协议中浏览器客户端在同一时间**，**针对同一域名下的请求有一定数量限制**，**超过限制数目的请求会被阻塞**，这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，而**HTTP/2 的多路复用**则**允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息**，因此 HTTP/2**可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接**。
   2. 这种**单连接多资源**的方式，**减少了服务端的连接压力**，**内存占用更少**，**连接吞吐量更大**，而且**由于 TCP 连接的减少**，**使得网络拥塞状况得以改善**，同时**慢启动的减少**，**使得拥塞和丢包恢复速度更快**。

      > HTTP2.0 的多路复用和 HTTP1.1 中的长连接复用有什么区别？
      >
      > 1. **HTTP/1.**\*：**一次请求一个响应**，**建立一个连接**，**用完关闭**，即**每一个请求都要建立一个连接**。
      > 2. ****HTTP/1.1****：采用**Pipeling**的解决方式，**若干个请求排队串行化单线程处理**，**后面的请求等待前面请求的返回才能获得执行机会**，**一旦有某请求超时**，**后续请求只能被阻塞**，也就是人们常说的**线头阻塞**。
      > 3. **HTTP/2**：**多个请求可同时在一个连接上并行执行**，**某个请求任务耗时严重**，**不会影响到其他连接的正常执行**。
      >
2. **请求优先级**：

   1. HTTP2.0 使用一个**31 比特**的优先值，**0 表示最高优先级**，**$ 2^{31} - 1 $ 表示最低优先级**，**服务器端可以根据优先级**，**控制资源分配**，**优先处理和返回最高优先级的请求帧给客户端**。
3. **二进制分帧**：

   1. HTTP1.1 的解析是**基于文本**，基于文本协议的格式解析存在天然缺陷，因为**文本的表现形式有多样性**，**要做到健壮性考虑的场景必然很多**，而**二进制**则不同，**只认 0 和 1 组合**，因此基于这种考虑**HTTP2.0 的协议解析**决定**采用二进制格式**，**实现方便且健壮**。
   2. HTTP/2 在应用层和传输层之间**增加了一个二进制分帧层**，在二进制分帧层中 HTTP/2 会**将所有传输的信息分割为更小的消息和帧**，并对他们**采用二进制格式的编码**，其中**HTTP1.x 的首部信息会被封装在 HEADER frame 里**，而**相应 Request Body 则封装在 DATA frame 里**，这样便可以**在不改动 HTTP/1.x 的语义**、**方法**、**状态码以及首部字段的情况下**，**解决了 HTTP1.1 的性能限制**，**改进了传输性能**，**实现低延迟和高吞吐量**。
4. **头部压缩**：

   1. **HTTP/1.1并不支持HTTP首部压缩**，**HTTP/2则使用了专门为首部压缩而设计的HPACK算法**。

      > 为什么需要头部压缩？
      >
      > 1. 假设一个页面有100个资源需要加载，而每一次请求都有1KB的消息头，则至少需要多消耗100KB来获取这些消息头。
      > 2. HTTP2.0可以**维护一个字典**，**差量更新HTTP头部**，**大大降低因头部传输产生的流量**。
      >
5. **服务端推送**：

   1. 在HTTP/2中，服务器可以**对客户端的一个请求发送多个响应**。
   2. 如果**一个请求是由我们的主页发起的**，服务器很**可能会响应主页内容**、**Logo及样式表**，因为**他知道客户端会用到这些东西**。
   3. 同时服务器端推送还有一个很大的优势，就是**可以缓存**，这让**在遵循同源的情况下**，**不同页面之间共享缓存资源成为可能**。

## 参考文献

1. [HTTP 1.0/1.1/2.0 的区别与联系](https://www.cnblogs.com/lifan1998/p/14326703.html)。
