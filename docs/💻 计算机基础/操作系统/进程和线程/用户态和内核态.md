---
sidebar_position: 11
---

## 1 特权级

1. 在介绍用户态和核心态之前，先介绍一下特权级，特权级是**指令级架构**（Instruction Set Architecture, ISA）**的重要组成部分**，AArch64 中的特权级称为**异常级别**（Exception Level, EL），共有**四种特权级**：
   ![](https://notebook.grayson.top/media/202207/2022-07-06_150541_847019.png)
   1. **EL0**：**最低的特权级**，**应用程序通常运行在该特权级**，也称为**用户态**。
   2. **EL1**：**操作系统通常运行在该特权级**，也称为**内核态**。
   3. **EL2**：在**虚拟化场景**下需要，**虚拟机监控器**（Virtual Machine Monitor, VMM）**通常运行在该特权级**。
   4. **EL3**：**和安全特性 TrustZone 相关**，**负责普通世界和安全世界之间的切换**。

## 2 什么是用户态和内核态

1. 为了**限制不同程序的访问能力**，**防止一些程序访问其他程序的内存数据**，CPU 划分了用户态和内核态两个权限等级：
   1. **用户态**只能**受限地访问内存**，且**不允许访问外围设备**，**没有占用 CPU 的能力**，**CPU 资源可以被其他程序获取**。
   2. **内核态可以访问内存所有数据以及外围设备**，**也可以进行程序的切换**。
2. **所有用户程序都运行在用户态**，但有时需要进行一些**内核态的操作**，比如**从硬盘或者键盘读数据**，这时就需要进行**系统调用**，**使用陷阱指令**，**CPU 切换到内核态，执行相应的服务，再切换回用户态并返回系统调用的结果**。

## 3 为什么要区分用户态和内核态

1. 主要是为了区别执行**特权指令**和**非特权指令**。
2. 在 CPU 的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃，比如**清内存、设置时钟等**。
3. 所以，CPU 将指令分为特权指令和非特权指令，对于那些**危险的指令**，**只允许操作系统及其相关模块使用**，**普通的应用程序只能使用那些不会造成灾难的指令**。

## 3 用户态和内核态之间如何切换

用户态和内核态之间的切换主要有三种方式，分别是**系统调用、中断、异常**。

### 3.1 系统调用

1. 这是**用户态进程主动要求切换到内核态**的一种方式，**用户态进程**通过**系统调用**申请**使用操作系统提供的服务程序完成工作**，比如 `fork()` 实际上就是执行了一个创建新进程的系统调用。
2. 而**系统调用**的机制其**核心**还是使用了操作系统为用户特别开放的一个**中断**来实现的。

### 3.2 中断

1. 当**外围设备完成用户请求操作**后，会**向 CPU 发出相应的中断信号**，这时**CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序**。
2. 如果**先前执行的指令是用户态下的程序**，那么这个转换的过程**自然也就发生了由用户态到内核态的切换**，比如**硬盘读写操作完成**，**系统会切换到硬盘读写的中断处理程序中执行后续操作**。

### 3.3 异常

1. 当 CPU 在**执行运行在用户态下的程序**时，**发生了某些事不可知的异常**，这时会**触发由当前运行进程切换到处理此异常的内核相关程序**中，也就**转到了内核态**，比如**缺页异常**。

## 4 用户态和内核态之间的切换流程

![](https://notebook.grayson.top/media/202207/2022-07-06_162103_019791.png)

1. **保存当前执行状态**：
   1. 保存当前执行状态主要**由 CPU 负责完成**，**以便操作系统内核在处理异常时使用并在处理结束后能够恢复应用程序的执行**。
   2. CPU 保存的主要状态包括：
      1. **触发异常的指令地址**（即当前**程序计数器**（Program Counter, PC）），**保存在 ELR_EL1**（异常链接寄存器（Exception Link Register））**中**。
      2. **异常原因**（即异常是由于执行特权调用（Supervisor Call）指令还是由于访存缺页导致的），**保存在 ESR_EL1**（异常症状寄存器（Exception Syndrome Register））**中**。
      3. CPU**将栈指针**（Stack Pointer, SP）**从 SP_EL0**（应用程序使用的栈）**切换到 SP_EL1**（已保存的程序状态寄存器（Saved Program Status Register））**中**，**将引发缺页异常的地址保存在 FAR_EL1**（错误地址寄存器（Fault Address Register））**中**。
2. **获取异常向量表**：
   1. 操作系统可以在异常向量表中**为不同的异常类型配置相应的异常处理函数**。
   2. 因此，当发生特权切换时，CPU 会**读取 VBAR_EL1**（向量基地址寄存器（Vector Base Address Register））**来获得异常向量表的基地址**，然后**根据异常原因**（ESR_EL1 中保存的内容）**获取操作系统设置的相应异常处理函数**，
3. **执行异常处理函数**：
   1. 一般来说异常处理函数会先**保存应用程序的上下文**（比如通用寄存器）。
   2. **根据异常原因执行相应的异常处理函数来进行相应的处理**，若特权级切换是访存过程中缺页异常导致的，则执行相应的缺页异常处理函数。
4. **恢复异常发生前的状态**：
   1. 在异常处理完成后，操作系统会**恢复应用程序的上下文**，然后**执行 `eret`**（异常返回（Exception Return））**指令以恢复 CPU 自动保存的 EL0 状态**（包括 PC 和 SP 等），并**切换到 EL0**，**使应用程序从被中断处继续执行**。

## 附录

### A TrustZone

#### A.1 背景

> 在介绍 TrustZone 之前先回顾一下目前的一些安全手段。

1. CPU 通过**虚拟地址**给每个进程营造一个单独的地址空间来**隔离多个进程的代码和数据**，通过**内核空间**和**用户空间**不同的特权级来**隔离操作系统和用户进程的代码和数据**。
2. 但由于**内存中的代码和数据都是明文**，**容易被处于内存中的其他应用偷窥**，因此出现了**扩展的安全模块**，**应用将加密数据送往安全模块**，**由安全模块处理完后再返回结果给相应的应用**。
3. 很多消费电子设备都使用扩展的安全模块来确保数据安全，目前常见的方式有：
   1. **外部挂接硬件安全模块**：
      1. **数据的处理交由外部的安全模块实现**，**这些模块能够保护自己的资源和密钥等数据的安全**，如 SIM 卡、各种智能卡或连接到外部的硬件加解密模块等。
      2. 但是这种方式**与主芯片的通信线路暴露在外部**，**容易被监听破解**，同时，**通信的速率比较低**。
   2. **内部集成硬件安全模块**：
      1. **将外部安全模块的功能集成到芯片内**，因此一个芯片上至少有**两个核**，分别为一个**普通核**和一个**安全核**。
      2. 这种方式的优点是**核与核之间的通信在芯片内部实现**，**不再暴露在外面**，缺点是**核之间的通信速度仍然较低**，而且**单独的安全核性能有限**，**还会占用 SoC 面积**，**成本较高**。

#### A.2 含义

1. TrustZone 是**ARM 针对消费电子设备设计的一种硬件架构**，其**目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击**。
2. TrustZone**在概念上将 SoC 的硬件和软件资源划分为安全世界**（Secure World）**和非安全世界**（Normal World），**所有需要保密的操作在安全时间执行**（如指纹识别、密码处理、数据加解密、安全认证等），**其余操作在非安全世界执行**（如用户操作系统、各种应用程序等），**安全世界和非安全世界通过一个名为 Monitor Mode 的模式进行转换**。
   ![](https://notebook.grayson.top/media/202207/2022-07-06_155752_164663.png)
3. 处理器架构上，TrustZone**将每个物理核虚拟为两个核**，一个**非安全核**（Non-Secure Core, NS Core），**运行非安全世界的代码**，另一个为**安全核**（Secure Core），**运行安全世界的代码**，**两个虚拟的核以基于时间片的方式运行**，**根据需要实时占用物理核**，**并通过 Monitor Mode 在安全世界和非安全世界之间切换**，**类似同一 CPU 下的多应用程序环境**，**不同的是多应用程序环境下操作系统实现的是进程间切换**，**而 TrustZone 下的 Monitor Mode 实现了同一 CPU 上两个操作系统间的切换**。

## 参考文献

1. 《现代操作系统：原理与实现》
2. [一篇了解 TrustZone](https://blog.csdn.net/guyongqiangx/article/details/78020257)。
3. [什么是用户态和内核态？](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81)
4. [用户态和核心态的概念以及为什么要区别？以及两者之间的切换](https://www.codenong.com/cs105695961)
