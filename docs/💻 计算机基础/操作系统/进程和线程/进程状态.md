---
sidebar_position: 4
---

## 一般情况

一般来说，进程可以处于以下 :point_down: 状态：

- **新生状态**（`new`）：
  - 该状态表示一个进程刚刚被创建出来，还 **未完成初始化**，不能被调度执行。
  - 在经过初始化过程之后，进程迁移至 **预备状态**。
- **预备状态**（`ready`）：
  - 该状态表示进程 **可以被调度执行**，但还 **未被调度器选择**。
  - 由于 CPU 数量可能少于进程数量，在某一时刻只有部分进程能被调度到 CPU 上执行，此时，系统中其他的可被调度的进程都处于预备状态。
  - 在 **被调度器选择执行** 后，进程迁移至 **运行状态**。
- **运行状态**（`running`）：
  - 该状态表示进程 **正在 CPU 上运行**。
  - 当一个进程执行一段时间后，调度器可以选择 **中断** 他的执行并重新将其放回到 **调度队列**，他就迁移至 **预备状态**。
  - 当进程 **运行结束**，他会迁移至 **终止状态**。
  - 如果一个进程需要 **等待某些外部事件**，他可以 **放弃 CPU** 并迁移至 **阻塞状态**。
- **阻塞状态**（`blocked`）：
  - 该状态表示进程需要 **等待外部事件**（如某个 I/O 请求的完成），暂时 **无法被调度**。
  - 当进程等待的 **外部事件完成** 后，他会迁移至 **预备状态**。
- **终止状态**（`terminated`）：
  - 该状态表示进程已经 **完成了执行**，且 **不会再被调度**。

![image-20220723160142189](https://notebook.grayson.top/media/202207/2022-07-23_160146_5254400.16806153497324605.png)

## 复杂情况

复杂情况下，进程可以处于以下 :point_down: 状态，相比于上面的 :point_up_2: 简单情况，多了如下两个状态：

- **挂起预备状态**：
  - 当 **中期调度** 将 **预备状态** 的进程 **挂起** 后，会对应地将进程设置为 **挂起预备状态**。
- **挂起阻塞状态**：
  - 当 **中期调度** 将 **阻塞状态** 的进程 **挂起** 后，会对应地将进程设置为 **挂起阻塞状态**。
  - 在 **对应事件被触发** 时会被设置为 **挂起预备状态**。

> ⚠️ 处于以上两种状态的进程都 **无法被短期调度执行**。

![image-20220723205039585](https://notebook.grayson.top/media/202207/2022-07-23_205045_0122300.9522581985429909.png)



## 进程调度

![image-20220724144139883](https://notebook.grayson.top/media/202207/2022-07-24_144146_2298730.020916809527830482.png)

1. 在传统操作系统中，批处理任务被发起后，其信息会被存入磁盘中的 **批处理队列**，等待被 **长期调度** 允许进入系统。
2. 长期调度负责从批处理队列中 **选取下一个可被调度的批处理任务**，为其 **创建相应的进程**，将进程设为 **预备状态** 并 **放入运行队列**。
3. 由于 **交互式任务** 和 **实时任务** 一般都有比较高的时延要求，需要在一定时间内返回结果，所以这两类任务一般 **不会被长期调度管理**，系统会 **直接为他们创建对应的进程**，将进程设为 **预备状态** 并 **放入运行队列**。
4. 通过 **短期调度** 的决策，运行队列中的进程会被 **调度到 CPU 上执行**，此时进程为 **运行状态**。
5. 当进程 **运行完一个时间片** 后，短期调度会将其重新置为 **预备状态**，并放回 **运行队列**。
6. 当 **运行中的进程发起 I/O 请求**，等待用户输入或进入睡眠，因而需要被阻塞时，会被放入 **阻塞队列** 中，短期调度会 **选择其他进程进行调度**。
7. 当进程 **等待的事件被触发** 后，操作系统直接将对应的进程 **移出阻塞队列**，并将其置为 **预备状态**，重新放入 **运行队列** 中。
8. 如果系统中的 **内存使用量过大**，就会触发 **换页机制**，**中期调度** 会 **挂起** 处于预备状态 / 阻塞状态的进程，将其置为 **挂起预备状态** / **挂起阻塞状态** 并放入 **挂起运行队列** / **挂起阻塞队列** 中。
9. 当系统中的 **内存使用情况不再紧张** 时，**中期调度** 会 **激活** 挂起运行队列 / 挂起阻塞队列中的进程，将其置为预备状态 / 阻塞状态并 **放回运行队列** / **阻塞队列中**。
10. 当进程 **结束执行** 后，会进入 **终止状态** 并最终被 **回收**。

## 参考文献

1. 《现代操作系统：原理与实现》