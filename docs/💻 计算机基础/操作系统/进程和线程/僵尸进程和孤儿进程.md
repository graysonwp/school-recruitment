---
sidebar_position: 6
---

## 1 僵尸进程

### 1.1 含义

1. 当一个**子进程结束运行**（一般是调用 `exit`、运行时发生致命错误或收到终止信号导致）时，其**退出状态会汇报给操作系统**，**系统则以 `SIGCHLD` 信号将子进程被结束的事件告知父进程**，此时，**子进程的进程控制块（PCB）仍驻留在内存中**。
2. 一般来说，**收到 `SIGCHLD` 后，父进程会使用 `wait` 系统调用以获取子进程的退出状态**，然后**内核**就可以**从内存中释放已结束的子进程的 `PCB`**。
3. 如果**父进程没有调用 `wait` 或 `waitpid` 获取子进程的状态信息时，子进程的 PCB 就会一直驻留在内存中，成为僵尸进程**。

### 1.2 特点

1. 僵尸进程是一个**死亡的进程**，但是并**没有真正被销毁**。
2. 他已经**放弃了几乎所有内存空间**，**没有任何可执行代码**，也**不能被调度**，**仅仅在进程表中保留一个位置**，**记载该进程的进程 ID、终止状态以及资源利用信息**（CPU 时间，内存使用量等）**供父进程收集**，**除此之外，僵尸进程不再占用任何内存空间**。
3. 这个僵尸进程可能会**一直留在系统中，直到系统重启**。

### 1.3 危害

1. **占用进程号**，而系统所能使用的进程号是有限的，如果产生大量的僵尸进程，就会因为**没有可用的进程号而导致系统不能产生新的进程**。

### 1.4 如何杀死僵尸进程

1. 重启服务器。
2. 找到该僵尸进程的父进程，并将该进程的父进程杀掉，则此僵尸进程会自动消失。

> 查找僵尸进程的方法：`ps aux  | grep -w 'Z'`

### 1.5 如何避免僵尸进程

1. 父进程在**创建子进程之前**，就**调用 `signal(SIGCHLD,SIG_IGN)` 向系统申明自己不会对这个子进程的 `exit` 动作进行任何关注行为**，这样**子进程一旦退出，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了**。
2. 父进程创建子进程后**调用 `wait` 或 `waitpid` 等待子进程结束**，但是这**会导致父进程挂起**。
3. 父进程在创建子进程的时候，**连续调用两次 `fork()`**，而且**使紧跟的子进程退出，使其孙子进程成为孤儿进程，从而 `init` 进程将代替父进程来接手，负责清除这个孤儿进程**，于是父进程就无须进行任何的清理行为，系统会自动处理。
4. 采用**信号量处理函数**，父进程首先**注册一个信号处理函数 `signal(SIGCHLD, sig_chld_handler)`**，然后每**当子进程退出的时候，父进程都会收到 `SIGCHLD`，然后在 `sig_chld_handler` 中调用 `wait` 函数等待子进程的退出**。

## 2 孤儿进程

### 2.1 含义

1. 一个**父进程退出**，而他的**一个或多个子进程还在运行**，那么**那些子进程将成为孤儿进程**，**孤儿进程被 `init` 进程（进程号为 1）所收养，并由 `init` 进程对他们完成状态收集工作**。

## 参考文献

1. [进程 3.0——进程状态与僵尸进程、孤儿进程](https://zhuanlan.zhihu.com/p/96098130)。
2. [什么是僵尸进程？](https://github.com/wolverinn/Waking-Up/blob/master/Operating%20Systems.md#%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B)
3. [僵尸进程的产生和危害](https://blog.51cto.com/u_3653220/2372808)。
4. [Kill 杀死 Linux 中的 defunct 进程(僵尸进程)](https://blog.csdn.net/DarrenXf/article/details/82970809)。
5. [Linux 编程中如何避免出现僵尸进程](https://blog.csdn.net/sty23122555/article/details/51199781)。
6. [僵尸进程的存在意义、危害及避免方法](https://www.jianshu.com/p/964aff4fad24)。

